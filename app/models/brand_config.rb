class BrandConfig < ActiveRecord::Base
  include BrandableCSS

  self.primary_key = 'md5'
  serialize :variables, Hash

  attr_accessible :variables, :js_overrides, :css_overrides

  validates :variables, presence: true, unless: :overrides?
  validates :md5, length: {is: 32}

  before_validation :generate_md5
  before_update do
    raise 'BrandConfigs are a key-value mapping of config variables and an md5 digest '\
          'of those variables, so they are immutable. You do not update them, you just '\
          'save a new one and it will generate the new md5 for you'
  end

  has_many :accounts, foreign_key: 'brand_config_md5'

  scope :without_k12, lambda { where("md5 != ?", BrandConfig.k12_config) }

  scope :shared, -> (account = nil) {
    shared_scope = where(share: true)
    shared_scope = shared_scope.without_k12 unless account && account.feature_enabled?(:k12)
    shared_scope
  }

  def self.for(variables:, js_overrides:, css_overrides:)
    if variables.blank? && js_overrides.blank? && css_overrides.blank?
      default
    else
      new_config = new(variables: variables, js_overrides: js_overrides, css_overrides: css_overrides)
      existing_config = where(md5: new_config.generate_md5).first
      existing_config || new_config
    end
  end

  def self.default
    new
  end

  def self.k12_config
    BrandConfig.where(name: 'K12 Theme', share: true).first
  end

  def default?
    self.variables.blank? && self.js_overrides.blank? && self.css_overrides.blank?
  end

  def generate_md5
    self.id = Digest::MD5.hexdigest([
      self.variables.to_s,
      self.css_overrides,
      self.js_overrides
    ].join)
  end

  def get_value(variable_name)
    self.variables[variable_name]
  end

  def overrides?
    self.js_overrides.present? || self.css_overrides.present?
  end

  def to_scss
    "// This file is autogenerated by brand_config.rb as a result of running `rake brand_configs:write`\n" +
    variables.map do |name, value|
      next unless (config = BrandableCSS.variables_map[name])
      value = %{url("#{value}")} if config['type'] == 'image'
      "$#{name}: #{value};"
    end.compact.join("\n")
  end

  def scss_file
    scss_dir.join('_brand_variables.scss')
  end

  def scss_dir
    BrandableCSS.branded_scss_folder.join(md5)
  end

  def public_folder
    "dist/brandable_css/#{md5}"
  end

  def save_scss_file!
    logger.info "saving brand variables file: #{scss_file}"
    scss_dir.mkpath
    scss_file.write(to_scss)
  end

  def remove_scss_file!
    return unless scss_dir.exist?
    logger.info "removing: #{scss_dir}"
    scss_dir.rmtree
  end

  def compile_css!
    BrandableCSS.compile_brand!(md5)
  end

  def sync_to_s3!(&block)
    Canvas::Cdn.push_to_s3!(public_folder, &block) if Canvas::Cdn.enabled?
  end

  def save_and_sync_to_s3!(progress=nil)
    progress.update_completion!(5) if progress
    save_scss_file!
    progress.update_completion!(10) if progress
    compile_css!
    progress.update_completion!(50) if progress
    sync_to_s3! do |percent_complete|
      # send at most 1 UPDATE query per 2 seconds
      if progress && (progress.updated_at < 2.seconds.ago)
        total_percent = 50 + percent_complete / 2
        progress.update_completion!(total_percent)
      end
    end
  end

  def self.destroy_if_unused(md5)
    return unless md5
    unused_brand_config = BrandConfig.
      where(md5: md5).
      where("NOT EXISTS (?)", Account.where("brand_config_md5=brand_configs.md5")).
      where("NOT share").
      first
    if unused_brand_config
      unused_brand_config.destroy
      unused_brand_config.remove_scss_file!
    end
  end

  def self.clean_unused_from_db!
    BrandConfig.
      where("NOT EXISTS (?)", Account.where("brand_config_md5=brand_configs.md5")).
      where('NOT share').
      # When someone is actively working in the theme editor, it just saves one
      # in their session, so only delete stuff that is more than a week old,
      # to not clear out a theme someone was working on.
      where(["created_at < ?", 1.week.ago]).
      delete_all
  end

end
